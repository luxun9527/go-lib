package main

import (
	"fmt"
	"github.com/pkg/errors"
	"github.com/spf13/cast"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)
// 定义文件描述结构体
type fileDesc struct {
	FileName string
	PkgName          string
	ConstantDescList []*constantDesc
	FileComments string
}
// 定义常量描述结构体
type constantDesc struct {
	CodeName string
	VarName string
	Value   int32
	Comment string
	ConcatStr string
}

func main() {
	fileFullPath, err := filepath.Abs("utils\\ast\\code.go")
	if err!=nil{
		panic(errors.WithMessage(err,"获取文件路径失败"))
	}
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileFullPath, nil, parser.ParseComments)
	if err != nil {
		panic(errors.WithMessage(err,"解析文件失败"))
	}

	const (
		filedSuffix = "Code"
	)
	var (
		currentVal = int32(0)
		fd =  &fileDesc{}
	)
	fd.FileName = fileFullPath
	ast.Inspect(f, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.File:
			// 获取文件包名
			if node.Name == nil {
				panic("invalid go file")
			}
			fd.PkgName = node.Name.Name
		case *ast.ValueSpec:
			// 获取文件中定义的常量
			d := &constantDesc{}
			names := node.Names
			if len(names) == 0 {
				return true
			}
			//name
			name := names[0].Name
			if !strings.HasSuffix(name, filedSuffix) {
				return true
			}
			d.CodeName = name
			d.VarName = strings.TrimSuffix(name, filedSuffix)
			//Value
			for _, v := range node.Values {
				e, ok := v.(*ast.BinaryExpr)
				if ok {
					l, ok := e.Y.(*ast.BasicLit)
					if ok {
						d.Value = cast.ToInt32(l.Value)
						currentVal = d.Value
					}
				}
			}
			if d.Value == 0 {
				currentVal++
				d.Value = currentVal
			}
			//Comment
			var comment string
			if node.Comment != nil {
				comment = node.Comment.Text()
			}
			if node.Doc != nil {
				comment = node.Doc.Text()
			}
			d.Comment = strings.TrimSpace(comment)
			fd.ConstantDescList = append(fd.ConstantDescList, d)

		}
		return true
	})
	log.Printf("%+v", fd)
	castToGrpcError(fd)
}

const tpl = `
// Code generated by tool. DO NOT EDIT.
// Code generated by tool. DO NOT EDIT.
// Code generated by tool. DO NOT EDIT.

package {{.PkgName}}

import (
	"google.golang.org/grpc/status"
)

var (
	{{- range $idx, $constDesc :=  .ConstantDescList}}
	{{ $constDesc.ConcatStr }}	
	{{- end }}
)
/*

{{ .FileComments }}

*/
`
//根据解析出来的数据转为grpc的错误定义
func castToGrpcError(c *fileDesc)  {
	const fileSuffix = ".err.go"
	p, err := template.New("").Funcs(template.FuncMap{}).Parse(tpl)

	if err !=nil{
		panic(errors.WithMessage(err,"parse template failed"))
	}
	base := filepath.Dir(c.FileName)
	n := strings.TrimSuffix(filepath.Base(c.FileName),".go")
	fileFullPath := filepath.Join(base,n+fileSuffix)
	f, err := os.OpenFile(fileFullPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err !=nil{
		panic(errors.WithMessage(err,"open file failed"))
	}
	var (

		fileComments string
	)

	for _,v := range c.ConstantDescList {
		v.ConcatStr = fmt.Sprintf("%-15s %-3s %-8s",v.VarName,"=",fmt.Sprintf(`status.Error(%v,%v)`,v.CodeName,"\""+v.Comment+"\""))
		fileComments +=fmt.Sprintf("%-8d%-10s\n",v.Value,v.Comment)
	}

	c.FileComments = fileComments
	if err := p.Execute(f, c);err!=nil{
		panic(errors.WithMessage(err,"execute template failed"))
	}

}
