package main

import (
	"flag"
	"fmt"
	"github.com/spf13/cast"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)
// 定义文件描述结构体
type fileDesc struct {
	FileName string
	PkgName          string
	ConstantDescList []*constantDesc
	FileComments string
}
// 定义常量描述结构体
type constantDesc struct {
	CodeName string
	VarName string
	Value   int32
	Comment string
	ConcatStr string
}





func main() {
	codePath := flag.String("p","","错误码路径")
	flag.Parse()
	pathList, err := filepath.Glob(*codePath)
	if err!=nil{
		log.Panicf("文件路径错误:%v",err)
	}
	if len(pathList)==0{
		log.Printf("该目录下无匹配的文件%v",*codePath)
		return
	}

	for _,path := range pathList {
		fileFullPath, err := filepath.Abs(path)
		if err!=nil{
			log.Panicf("文件路径错误:%v path=%v",err,fileFullPath)
		}
		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, fileFullPath, nil, parser.ParseComments)
		if err != nil {
			log.Panicf("解析文件失败:%v",err)
		}

		const (
			filedSuffix = "Code"
		)
		var (
			currentVal = int32(0)
			fd =  &fileDesc{}
		)
		fd.FileName = fileFullPath
		ast.Inspect(f, func(n ast.Node) bool {
			switch node := n.(type) {
			case *ast.File:
				// 获取文件包名
				if node.Name == nil {
					panic("invalid go file")
				}
				fd.PkgName = node.Name.Name
			case *ast.ValueSpec:
				// 获取文件中定义的常量
				d := &constantDesc{}
				names := node.Names
				if len(names) == 0 {
					return true
				}
				//name
				name := names[0].Name
				if !strings.HasSuffix(name, filedSuffix) {
					return true
				}
				d.CodeName = name
				d.VarName = strings.TrimSuffix(name, filedSuffix)
				//Value
				for _, v := range node.Values {
					e, ok := v.(*ast.BinaryExpr)
					if ok {
						l, ok := e.Y.(*ast.BasicLit)
						if ok {
							d.Value = cast.ToInt32(l.Value)
							currentVal = d.Value
						}
					}
				}
				if d.Value == 0 {
					currentVal++
					d.Value = currentVal
				}
				//Comment
				var comment string
				if node.Comment != nil {
					comment = node.Comment.Text()
				}
				if node.Doc != nil {
					comment = node.Doc.Text()
				}
				d.Comment = strings.TrimSpace(comment)
				fd.ConstantDescList = append(fd.ConstantDescList, d)

			}
			return true
		})
		castToGrpcError(fd)
	}

}

const tpl = `
// Code generated by tool. DO NOT EDIT.
// Code generated by tool. DO NOT EDIT.
// Code generated by tool. DO NOT EDIT.

package {{.PkgName}}

import (
	"google.golang.org/grpc/status"
)

var (
	{{- range $idx, $constDesc :=  .ConstantDescList}}
	{{ $constDesc.ConcatStr }}	
	{{- end }}
)
/*

{{ .FileComments }}

*/
`
//根据解析出来的数据转为grpc的错误定义
func castToGrpcError(c *fileDesc)  {
	const fileSuffix = ".err.go"
	p, err := template.New("").Funcs(template.FuncMap{}).Parse(tpl)
	if err !=nil{
		log.Panicf("parse template failed,err:%v",err)
	}
	base := filepath.Dir(c.FileName)
	n := strings.TrimSuffix(filepath.Base(c.FileName),".code.go")
	fileFullPath := filepath.Join(base,n+fileSuffix)
	f, err := os.OpenFile(fileFullPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err !=nil{
		log.Panicf("open file failed,err:%v fileFullPath=%v",err,fileFullPath)
	}
	var (

		fileComments string
	)

	for _,v := range c.ConstantDescList {
		v.ConcatStr = fmt.Sprintf("%-15s %-3s %-8s",v.VarName,"=",fmt.Sprintf(`status.Error(%v,%v)`,v.CodeName,"\""+v.Comment+"\""))
		fileComments +=fmt.Sprintf("%-8d%-10s\n",v.Value,v.Comment)
	}

	c.FileComments = fileComments
	if err := p.Execute(f, c);err!=nil{
		log.Panicf("execute template failed,err:%v",err)
	}

}
