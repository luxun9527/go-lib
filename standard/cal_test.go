package standard

import (
	"github.com/spf13/cast"
	"log"
	"testing"
)

func TestCal(t *testing.T) {
	for i := 101; i >0; i-=100 {
		log.Println(i)
	}
	var i float32 =2.2

	log.Println(float64(i))
}

func TestFloat(t *testing.T){
	//小数的二进制算法。小数位乘以2 取整数位
	//1.3
	/*
		整数部分无符号0000 0001
		小数部分
			0.3 * 2=0.6整数位 0 .0
			0.6 * 2=1.2整数位 1 .01
			0.2 * 2 0.4整数位 0 .010
			0.4 * 2 0.8整数位 0 .0100
			0.8 * 2 1.6整数位 1 .01001
			0.6 * 2 1.2整数位 1 .010011
	        1.0100110011001100110011001100110011001100110011001101
			https://www.cnblogs.com/xkfz007/archive/2012/02/27/2370357.html
			https://polarisxu.studygolang.com/posts/basic/diagram-float-point/
	    	https://baseconvert.com/ieee-754-floating-point

		浮点数的内存表示
	     单精度
	      符号位   指数位		尾数23位
		   0      0000 0000     0000 0000 0000 0000 0000 000
		120.5的内存标识
	    二进制表示 1111000.1
		1.1110001 *2的6次方
		正数无符号 0
		6+127=133 对应1000 0101
		尾数 1110001
		0 10000101 11100010000000000000000


	74080999549435905
	双精度
	 符号位   指数位11位		      尾数52位
	 0      0000 0000 000     0000 0000 0000 0000 0000 000
	二进制
	1 00000111 00110000 01000110 11001110 11000000 00000000 00000000
 	转为二进制的科学技术法
 	i := 1.0000 0111 0011 0000 0100 0110 1100 1110 1100 0000 0000 0000 0000 0000 * 56
	符号位0
	指数位12位 56+1023  1079 =10000110111
	尾数0000011100110000010001101100111011000000000000000000
	最终内存表示
	0 10000110111 0000011100110000010001101100111011000000000000000000
	//转换回来
	1.0000011100110000010001101100111011000000000000000000  * 2的56次方
	100000111001100000100011011001110110000000000000000000000 最终的二进制表示
	10进制表示 74080999549435900
	*/
	var f float64 =74080999549435905

	log.Println(cast.ToString(f))
}