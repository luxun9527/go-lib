// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm/model"
)

func newTdOrderExec(db *gorm.DB, opts ...gen.DOOption) tdOrderExec {
	_tdOrderExec := tdOrderExec{}

	_tdOrderExec.tdOrderExecDo.UseDB(db, opts...)
	_tdOrderExec.tdOrderExecDo.UseModel(&model.TdOrderExec{})

	tableName := _tdOrderExec.tdOrderExecDo.TableName()
	_tdOrderExec.ALL = field.NewAsterisk(tableName)
	_tdOrderExec.ID = field.NewInt64(tableName, "id")
	_tdOrderExec.CreatedAt = field.NewInt64(tableName, "created_at")
	_tdOrderExec.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_tdOrderExec.SeatNo = field.NewString(tableName, "seat_no")
	_tdOrderExec.ReportNo = field.NewString(tableName, "report_no")
	_tdOrderExec.ReportTime = field.NewInt64(tableName, "report_time")
	_tdOrderExec.ReportAccount = field.NewString(tableName, "report_account")
	_tdOrderExec.OrderInstructType = field.NewInt64(tableName, "order_instruct_type")
	_tdOrderExec.OrderInstructStatus = field.NewInt64(tableName, "order_instruct_status")
	_tdOrderExec.OrgID = field.NewString(tableName, "org_id")
	_tdOrderExec.ClientID = field.NewString(tableName, "client_id")
	_tdOrderExec.FundAccount = field.NewString(tableName, "fund_account")
	_tdOrderExec.TradeDate = field.NewInt64(tableName, "trade_date")
	_tdOrderExec.OrderTxnReference = field.NewString(tableName, "order_txn_reference")
	_tdOrderExec.ExchangeType = field.NewString(tableName, "exchange_type")
	_tdOrderExec.MoneyType = field.NewString(tableName, "money_type")
	_tdOrderExec.StockCode = field.NewString(tableName, "stock_code")
	_tdOrderExec.StockType = field.NewString(tableName, "stock_type")
	_tdOrderExec.EntrustBs = field.NewInt64(tableName, "entrust_bs")
	_tdOrderExec.EntrustProp = field.NewString(tableName, "entrust_prop")
	_tdOrderExec.EntrustAmount = field.NewFloat64(tableName, "entrust_amount")
	_tdOrderExec.EntrustPrice = field.NewFloat64(tableName, "entrust_price")
	_tdOrderExec.EntrustBalance = field.NewFloat64(tableName, "entrust_balance")
	_tdOrderExec.FrozenPrice = field.NewFloat64(tableName, "frozen_price")
	_tdOrderExec.FrozenAmount = field.NewFloat64(tableName, "frozen_amount")
	_tdOrderExec.FrozenBalance = field.NewFloat64(tableName, "frozen_balance")
	_tdOrderExec.NewEntrustAmount = field.NewFloat64(tableName, "new_entrust_amount")
	_tdOrderExec.NewEntrustPrice = field.NewFloat64(tableName, "new_entrust_price")
	_tdOrderExec.DeltaAmount = field.NewFloat64(tableName, "delta_amount")
	_tdOrderExec.DeltaBalance = field.NewFloat64(tableName, "delta_balance")
	_tdOrderExec.RegisterAmount = field.NewFloat64(tableName, "register_amount")
	_tdOrderExec.WithdrawAmount = field.NewFloat64(tableName, "withdraw_amount")
	_tdOrderExec.FilledAmount = field.NewFloat64(tableName, "filled_amount")
	_tdOrderExec.FilledBalance = field.NewFloat64(tableName, "filled_balance")
	_tdOrderExec.ExecNo = field.NewInt64(tableName, "exec_no")
	_tdOrderExec.ExecType = field.NewInt64(tableName, "exec_type")
	_tdOrderExec.ExecTime = field.NewInt64(tableName, "exec_time")
	_tdOrderExec.OrigClordID = field.NewString(tableName, "orig_clord_id")
	_tdOrderExec.ClordID = field.NewString(tableName, "clord_id")
	_tdOrderExec.F11Clordid = field.NewString(tableName, "f11_clordid")
	_tdOrderExec.F14Cumqty = field.NewFloat64(tableName, "f14_cumqty")
	_tdOrderExec.F39Ordstatus = field.NewInt64(tableName, "f39_ordstatus")
	_tdOrderExec.F150Exectype = field.NewString(tableName, "f150_exectype")
	_tdOrderExec.F151Leavesqty = field.NewFloat64(tableName, "f151_leavesqty")
	_tdOrderExec.ErrorType = field.NewString(tableName, "error_type")
	_tdOrderExec.ErrorNo = field.NewInt64(tableName, "error_no")
	_tdOrderExec.ErrorMsg = field.NewString(tableName, "error_msg")

	_tdOrderExec.fillFieldMap()

	return _tdOrderExec
}

type tdOrderExec struct {
	tdOrderExecDo tdOrderExecDo

	ALL                 field.Asterisk
	ID                  field.Int64   // 自增id
	CreatedAt           field.Int64   // 创建时间
	UpdatedAt           field.Int64   // 更新时间
	SeatNo              field.String  // 席位编号 IB111
	ReportNo            field.String  // 申报编号
	ReportTime          field.Int64   // 申报时间,UTC 单位(秒)
	ReportAccount       field.String  // 报盘机申报子账号
	OrderInstructType   field.Int64   // 报盘指令类型,1=新订单报盘指令(New Order),2=改单盘指令(Order Replace),3=撤单盘指令(Order Cancel)
	OrderInstructStatus field.Int64   // 报盘指令执行状态,0=待审核(Pending Review),1=未执行(No Execute),2=待执行(Pending Execute),3=执行中(Executing),4=执行完毕(Executed)
	OrgID               field.String  // 机构编号
	ClientID            field.String  // 客户编号 1090000320
	FundAccount         field.String  // 资产账户 109000032001
	TradeDate           field.Int64   // 交易日期 20220228
	OrderTxnReference   field.String  // 记录号 2022022800US0000000001
	ExchangeType        field.String  // 交易所类别 HK/US
	MoneyType           field.String  // 币种类别
	StockCode           field.String  // 证券代码
	StockType           field.String  // 证券类别 [AC_STOCK_TYPE]0:Stock 1:Fund D:WRNT F:BWRT U:BOND i:Inline Warrant
	EntrustBs           field.Int64   // 买卖方向 1=买(Buy),2=卖(Sell)
	EntrustProp         field.String  // 委托属性 [TD_ORDER_PROPERTIES]ALO:At-auction Limit Order  AO:At-auction Order  ASO:Auto Stage Order  BC:Bulk Cancel  ELO:Enhanced Limit Order  LO:Limit Order  M:Manual Trade  MO:Market Order  O:Odd Lot Trade  OBC:OBO Bulk Cancel  ODD:Odd Lot Input  P:Pre Opening Trade  SLO:Special Limit Order  SODD:Special Odd Lot Order  V:Overseas Trade
	EntrustAmount       field.Float64 // 委托数量
	EntrustPrice        field.Float64 // 委托价格
	EntrustBalance      field.Float64 // 委托金额
	FrozenPrice         field.Float64 // 已冻结价格
	FrozenAmount        field.Float64 // 已冻结数量
	FrozenBalance       field.Float64 // 已冻结金额
	NewEntrustAmount    field.Float64 // 新委托数量/改单数量
	NewEntrustPrice     field.Float64 // 新委托价格/改单价格
	DeltaAmount         field.Float64 // 追加数量
	DeltaBalance        field.Float64 // 追加价格
	RegisterAmount      field.Float64 // 登记股数/剩余挂单数量
	WithdrawAmount      field.Float64 // 撤单数量,撤成数量
	FilledAmount        field.Float64 // 已成交数量
	FilledBalance       field.Float64 // 已成交金额
	ExecNo              field.Int64   // 执行回报编号
	ExecType            field.Int64   // 执行回报类型 1=下单已报执行回报(OrderAccepted)，2=下单拒绝执行回报(OrderRejected)，3=成交执行回报(Filled)，4=改单成功执行回报(OrderReplaced)，5=撤单成功执行回报(OrderCancelled)，6=改单/撤单拒绝执行回报(CancelReject)
	ExecTime            field.Int64   // 执行回报时间,UTC 单位(秒)
	OrigClordID         field.String  // 原始客户订单号 -- tag41组成因子
	ClordID             field.String  // 客户订单号
	F11Clordid          field.String  // 报盘订单ID
	F14Cumqty           field.Float64 // 累计成交数量
	F39Ordstatus        field.Int64   // 订单状态 1 = New，2=Rejected，3=Partially Filled，4=Filled，5=Cancelled
	F150Exectype        field.String  // 执行类型
	F151Leavesqty       field.Float64 // 剩余数量
	ErrorType           field.String  // 错误类型 a=交易前置错误 b=柜台内部错误 s=报盘机返回错误 e=交易所返回错误
	ErrorNo             field.Int64   // 错误代码
	ErrorMsg            field.String  // 错误提示

	fieldMap map[string]field.Expr
}

func (t tdOrderExec) Table(newTableName string) *tdOrderExec {
	t.tdOrderExecDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tdOrderExec) As(alias string) *tdOrderExec {
	t.tdOrderExecDo.DO = *(t.tdOrderExecDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tdOrderExec) updateTableName(table string) *tdOrderExec {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.CreatedAt = field.NewInt64(table, "created_at")
	t.UpdatedAt = field.NewInt64(table, "updated_at")
	t.SeatNo = field.NewString(table, "seat_no")
	t.ReportNo = field.NewString(table, "report_no")
	t.ReportTime = field.NewInt64(table, "report_time")
	t.ReportAccount = field.NewString(table, "report_account")
	t.OrderInstructType = field.NewInt64(table, "order_instruct_type")
	t.OrderInstructStatus = field.NewInt64(table, "order_instruct_status")
	t.OrgID = field.NewString(table, "org_id")
	t.ClientID = field.NewString(table, "client_id")
	t.FundAccount = field.NewString(table, "fund_account")
	t.TradeDate = field.NewInt64(table, "trade_date")
	t.OrderTxnReference = field.NewString(table, "order_txn_reference")
	t.ExchangeType = field.NewString(table, "exchange_type")
	t.MoneyType = field.NewString(table, "money_type")
	t.StockCode = field.NewString(table, "stock_code")
	t.StockType = field.NewString(table, "stock_type")
	t.EntrustBs = field.NewInt64(table, "entrust_bs")
	t.EntrustProp = field.NewString(table, "entrust_prop")
	t.EntrustAmount = field.NewFloat64(table, "entrust_amount")
	t.EntrustPrice = field.NewFloat64(table, "entrust_price")
	t.EntrustBalance = field.NewFloat64(table, "entrust_balance")
	t.FrozenPrice = field.NewFloat64(table, "frozen_price")
	t.FrozenAmount = field.NewFloat64(table, "frozen_amount")
	t.FrozenBalance = field.NewFloat64(table, "frozen_balance")
	t.NewEntrustAmount = field.NewFloat64(table, "new_entrust_amount")
	t.NewEntrustPrice = field.NewFloat64(table, "new_entrust_price")
	t.DeltaAmount = field.NewFloat64(table, "delta_amount")
	t.DeltaBalance = field.NewFloat64(table, "delta_balance")
	t.RegisterAmount = field.NewFloat64(table, "register_amount")
	t.WithdrawAmount = field.NewFloat64(table, "withdraw_amount")
	t.FilledAmount = field.NewFloat64(table, "filled_amount")
	t.FilledBalance = field.NewFloat64(table, "filled_balance")
	t.ExecNo = field.NewInt64(table, "exec_no")
	t.ExecType = field.NewInt64(table, "exec_type")
	t.ExecTime = field.NewInt64(table, "exec_time")
	t.OrigClordID = field.NewString(table, "orig_clord_id")
	t.ClordID = field.NewString(table, "clord_id")
	t.F11Clordid = field.NewString(table, "f11_clordid")
	t.F14Cumqty = field.NewFloat64(table, "f14_cumqty")
	t.F39Ordstatus = field.NewInt64(table, "f39_ordstatus")
	t.F150Exectype = field.NewString(table, "f150_exectype")
	t.F151Leavesqty = field.NewFloat64(table, "f151_leavesqty")
	t.ErrorType = field.NewString(table, "error_type")
	t.ErrorNo = field.NewInt64(table, "error_no")
	t.ErrorMsg = field.NewString(table, "error_msg")

	t.fillFieldMap()

	return t
}

func (t *tdOrderExec) WithContext(ctx context.Context) ITdOrderExecDo {
	return t.tdOrderExecDo.WithContext(ctx)
}

func (t tdOrderExec) TableName() string { return t.tdOrderExecDo.TableName() }

func (t tdOrderExec) Alias() string { return t.tdOrderExecDo.Alias() }

func (t *tdOrderExec) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tdOrderExec) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 47)
	t.fieldMap["id"] = t.ID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["seat_no"] = t.SeatNo
	t.fieldMap["report_no"] = t.ReportNo
	t.fieldMap["report_time"] = t.ReportTime
	t.fieldMap["report_account"] = t.ReportAccount
	t.fieldMap["order_instruct_type"] = t.OrderInstructType
	t.fieldMap["order_instruct_status"] = t.OrderInstructStatus
	t.fieldMap["org_id"] = t.OrgID
	t.fieldMap["client_id"] = t.ClientID
	t.fieldMap["fund_account"] = t.FundAccount
	t.fieldMap["trade_date"] = t.TradeDate
	t.fieldMap["order_txn_reference"] = t.OrderTxnReference
	t.fieldMap["exchange_type"] = t.ExchangeType
	t.fieldMap["money_type"] = t.MoneyType
	t.fieldMap["stock_code"] = t.StockCode
	t.fieldMap["stock_type"] = t.StockType
	t.fieldMap["entrust_bs"] = t.EntrustBs
	t.fieldMap["entrust_prop"] = t.EntrustProp
	t.fieldMap["entrust_amount"] = t.EntrustAmount
	t.fieldMap["entrust_price"] = t.EntrustPrice
	t.fieldMap["entrust_balance"] = t.EntrustBalance
	t.fieldMap["frozen_price"] = t.FrozenPrice
	t.fieldMap["frozen_amount"] = t.FrozenAmount
	t.fieldMap["frozen_balance"] = t.FrozenBalance
	t.fieldMap["new_entrust_amount"] = t.NewEntrustAmount
	t.fieldMap["new_entrust_price"] = t.NewEntrustPrice
	t.fieldMap["delta_amount"] = t.DeltaAmount
	t.fieldMap["delta_balance"] = t.DeltaBalance
	t.fieldMap["register_amount"] = t.RegisterAmount
	t.fieldMap["withdraw_amount"] = t.WithdrawAmount
	t.fieldMap["filled_amount"] = t.FilledAmount
	t.fieldMap["filled_balance"] = t.FilledBalance
	t.fieldMap["exec_no"] = t.ExecNo
	t.fieldMap["exec_type"] = t.ExecType
	t.fieldMap["exec_time"] = t.ExecTime
	t.fieldMap["orig_clord_id"] = t.OrigClordID
	t.fieldMap["clord_id"] = t.ClordID
	t.fieldMap["f11_clordid"] = t.F11Clordid
	t.fieldMap["f14_cumqty"] = t.F14Cumqty
	t.fieldMap["f39_ordstatus"] = t.F39Ordstatus
	t.fieldMap["f150_exectype"] = t.F150Exectype
	t.fieldMap["f151_leavesqty"] = t.F151Leavesqty
	t.fieldMap["error_type"] = t.ErrorType
	t.fieldMap["error_no"] = t.ErrorNo
	t.fieldMap["error_msg"] = t.ErrorMsg
}

func (t tdOrderExec) clone(db *gorm.DB) tdOrderExec {
	t.tdOrderExecDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tdOrderExec) replaceDB(db *gorm.DB) tdOrderExec {
	t.tdOrderExecDo.ReplaceDB(db)
	return t
}

type tdOrderExecDo struct{ gen.DO }

type ITdOrderExecDo interface {
	gen.SubQuery
	Debug() ITdOrderExecDo
	WithContext(ctx context.Context) ITdOrderExecDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITdOrderExecDo
	WriteDB() ITdOrderExecDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITdOrderExecDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITdOrderExecDo
	Not(conds ...gen.Condition) ITdOrderExecDo
	Or(conds ...gen.Condition) ITdOrderExecDo
	Select(conds ...field.Expr) ITdOrderExecDo
	Where(conds ...gen.Condition) ITdOrderExecDo
	Order(conds ...field.Expr) ITdOrderExecDo
	Distinct(cols ...field.Expr) ITdOrderExecDo
	Omit(cols ...field.Expr) ITdOrderExecDo
	Join(table schema.Tabler, on ...field.Expr) ITdOrderExecDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITdOrderExecDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITdOrderExecDo
	Group(cols ...field.Expr) ITdOrderExecDo
	Having(conds ...gen.Condition) ITdOrderExecDo
	Limit(limit int) ITdOrderExecDo
	Offset(offset int) ITdOrderExecDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITdOrderExecDo
	Unscoped() ITdOrderExecDo
	Create(values ...*model.TdOrderExec) error
	CreateInBatches(values []*model.TdOrderExec, batchSize int) error
	Save(values ...*model.TdOrderExec) error
	First() (*model.TdOrderExec, error)
	Take() (*model.TdOrderExec, error)
	Last() (*model.TdOrderExec, error)
	Find() ([]*model.TdOrderExec, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TdOrderExec, err error)
	FindInBatches(result *[]*model.TdOrderExec, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TdOrderExec) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITdOrderExecDo
	Assign(attrs ...field.AssignExpr) ITdOrderExecDo
	Joins(fields ...field.RelationField) ITdOrderExecDo
	Preload(fields ...field.RelationField) ITdOrderExecDo
	FirstOrInit() (*model.TdOrderExec, error)
	FirstOrCreate() (*model.TdOrderExec, error)
	FindByPage(offset int, limit int) (result []*model.TdOrderExec, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITdOrderExecDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tdOrderExecDo) Debug() ITdOrderExecDo {
	return t.withDO(t.DO.Debug())
}

func (t tdOrderExecDo) WithContext(ctx context.Context) ITdOrderExecDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tdOrderExecDo) ReadDB() ITdOrderExecDo {
	return t.Clauses(dbresolver.Read)
}

func (t tdOrderExecDo) WriteDB() ITdOrderExecDo {
	return t.Clauses(dbresolver.Write)
}

func (t tdOrderExecDo) Session(config *gorm.Session) ITdOrderExecDo {
	return t.withDO(t.DO.Session(config))
}

func (t tdOrderExecDo) Clauses(conds ...clause.Expression) ITdOrderExecDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tdOrderExecDo) Returning(value interface{}, columns ...string) ITdOrderExecDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tdOrderExecDo) Not(conds ...gen.Condition) ITdOrderExecDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tdOrderExecDo) Or(conds ...gen.Condition) ITdOrderExecDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tdOrderExecDo) Select(conds ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tdOrderExecDo) Where(conds ...gen.Condition) ITdOrderExecDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tdOrderExecDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITdOrderExecDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tdOrderExecDo) Order(conds ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tdOrderExecDo) Distinct(cols ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tdOrderExecDo) Omit(cols ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tdOrderExecDo) Join(table schema.Tabler, on ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tdOrderExecDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tdOrderExecDo) RightJoin(table schema.Tabler, on ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tdOrderExecDo) Group(cols ...field.Expr) ITdOrderExecDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tdOrderExecDo) Having(conds ...gen.Condition) ITdOrderExecDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tdOrderExecDo) Limit(limit int) ITdOrderExecDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tdOrderExecDo) Offset(offset int) ITdOrderExecDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tdOrderExecDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITdOrderExecDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tdOrderExecDo) Unscoped() ITdOrderExecDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tdOrderExecDo) Create(values ...*model.TdOrderExec) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tdOrderExecDo) CreateInBatches(values []*model.TdOrderExec, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tdOrderExecDo) Save(values ...*model.TdOrderExec) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tdOrderExecDo) First() (*model.TdOrderExec, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TdOrderExec), nil
	}
}

func (t tdOrderExecDo) Take() (*model.TdOrderExec, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TdOrderExec), nil
	}
}

func (t tdOrderExecDo) Last() (*model.TdOrderExec, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TdOrderExec), nil
	}
}

func (t tdOrderExecDo) Find() ([]*model.TdOrderExec, error) {
	result, err := t.DO.Find()
	return result.([]*model.TdOrderExec), err
}

func (t tdOrderExecDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TdOrderExec, err error) {
	buf := make([]*model.TdOrderExec, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tdOrderExecDo) FindInBatches(result *[]*model.TdOrderExec, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tdOrderExecDo) Attrs(attrs ...field.AssignExpr) ITdOrderExecDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tdOrderExecDo) Assign(attrs ...field.AssignExpr) ITdOrderExecDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tdOrderExecDo) Joins(fields ...field.RelationField) ITdOrderExecDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tdOrderExecDo) Preload(fields ...field.RelationField) ITdOrderExecDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tdOrderExecDo) FirstOrInit() (*model.TdOrderExec, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TdOrderExec), nil
	}
}

func (t tdOrderExecDo) FirstOrCreate() (*model.TdOrderExec, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TdOrderExec), nil
	}
}

func (t tdOrderExecDo) FindByPage(offset int, limit int) (result []*model.TdOrderExec, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tdOrderExecDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tdOrderExecDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tdOrderExecDo) Delete(models ...*model.TdOrderExec) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tdOrderExecDo) withDO(do gen.Dao) *tdOrderExecDo {
	t.DO = *do.(*gen.DO)
	return t
}
